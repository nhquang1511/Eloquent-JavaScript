-----------------Functions--------------
function are one of the most central tools in javaScript programminng. the concept of wrapping a piece of program in a value has many uses. it gives us a way to structure larger program, to reduce repetition, to associate names with subprograms, and to isolate these subprograms from each other.
the most obvious application of funtions is defining new vocabulary. creating new words in prose is usually bad style, but in programming, it is indispensable
typical adult english speakers have some 20,000 words in their vocabulary. few programming language come with 20,000 command build in. and the vocabulary that is available tends to be more precisely defined, and thus less flexible, than in human language. therefore, we have to introduce new words to avoid excessive verbosity.

=============defining a function===============
a function definition is a regular binding where the value of the binding is a funtion. for example, this code defines to refer to a function that produces the square of a given number:

a function is created with an expression that starts with the keyword function. Functions have a set of parameters( in this case, only x) and a body, which contains the statements that are to be executed when the function is called. the body of a function created this way must always be wrapped in braces.even when it consist of only a single statement.

a funtion can have multiple parameters or no parameters at all. in the following example, makeNoise does not list any parameter names, whereas roundTo(which rounds n to the nearest multiple of step) lists two:

some functions such as roundto and square, produce a value and some don't, such as makenoise, whose only result is a side effect. A return statement determines the value the function returns. when control comes across such a statement, it immediately jumps out of the current function and gives the returned value to the code that called the function.A return keyword without an expression after it will cause the function to return undefined.
functions that don't have a return statement at all, such as makeNoise, similarly return undefined.
parameters to a funcwtion behave like regular binding, but their initial values are given by the caller of the function, not the code in the function itself.

==============binding and scopes=================
each binding has a scope, which is the part of the program in which the binding is visible. for biding defined outside of any function, block, or module(see chapter 10), the scope is the whole program- you can refer to such bindings wherever you want. these are called global.
binding created for function parameters or declared inside a funtion can be refenced only in that function, so they are known as local bindings. every time the function is called, new instances of these binding are created.
this provides some isolation between functions-each function call acts in its own littel world(its local environment) and can often be understood without knowing a lot about what's going on in the global environment.

binding declared with let and const are in fact local to the block in which they are declared, so if you create one of those inside of a loop, the code before and after the loop cannot "see" it. in pre-2015 javaScript, only functions created new scopes, so old-stye bindings, created with the var keyword, are visible throughout the whole function in which the appear-or throughout the global scope, if they are not in a funtion.

each scope can "look out" into the scope around it, so x is visible inside the block in the example. the exception is when multiple binding have the same name- in that case, code can see only the innermost one.for example, when the code inside the halve function refers to n, it is seeing its own n, not the global n.

--------------nested scope---------------------
javaScript distinguishes not just global and local binding. blocks and function can be created inside other blocks and functions, producting multiple degreens of locality.
for example, this function-which outputs the ingredients needed to make a batch of hummans-hash another function inside it:
the code inside the ingredients function can see the factor binding from the outer funcion, but its local bindings, such as unit or ingredientsAmount, are not visible in the outer function.

the set of binding visible inside a block is determined by the place of that block in the program text. each local scope can also see all the local scopes that contain it, and all scopes can see the global scope. this approach to biding visibility is called lexical scoping.

===================function as values===========
a function binding usually simply acts as name for a specific piece of the program. such a binding is defined once and never changed. this makes it easy to confuse the function and ist name.
but the two name different. a function value can do all the things that other values can do-you can use it in arbitrary expressions, not just call it. it is possible ot store a function value in a new binding, pass it as an argument to a function, and so on. similarly, a binding that holds a function is still just a regular binding and can, if not constant, be assinged a new value, like so:

in chapter 5, we'll discuss the interesting things that we can do by passing function values to other function.
=====================declaration notaion========
there is a slightly shorter way to create a function binding. when the function keyword is used at the start of a statement, it works differently;

this is a function declaration. the statement defines the binding square and point it at the given function. it is slightly easier to write and doesn't require a semicolon after the funciton.

there is one subtlety with this form of function deifnition.

console.log("the future says:", future());
the preceding code works, even though the function is defined below the code that uses it. funtion declaration are not part of the regular top to bottom flow of control. they are conceptually moved to the top of their scope and can be used by all the code in that scope. this is sometimes useful because it offers the freedom to order code in a way that seems the clearest, without worrying about having to define all funtions before they are used.

==============arrow functions=============
there's a third notation for funtions, which looks very different from the others. instead of the function keyword, it uses an arrow(=>) made up of an equal sign and a greater-then character(not to be confused with the greaterthen or equal operator, which is written>=):

the arrow comes after the list of parameters and it folowed by the function's body. it expresses something like "this input( the parameters) produces this result(the body)".
when there is only one parameter name, you can omit the parentheses around the parameter list. if the body is a singel expression rather than a block in braces,that expression will be returned from the function. so, these two definitions of square do the same thing:

const square1 = (x) =>{return x*x};
const square2 = x =>x*x;

when an arrow function has no parameters at all, its parameter list is just an empty set of parentheses.

there's no deep reason to have both arrow function and function expressions in the language. apart from a minor detail, which we'll discuss in chapter 6 they do the same thing. arrow function were added in 2015, mostly to make it possible to write small function expression in a less verbose way. we'll use them often in chapter 5.

===================the call stack==============
the way control flows through functions is somewhat involved. let's take a closer look at it. here is a simple program that makes a few function calls.:

a run through this program goes roughly like this: the call to greet causes control to jump to the start of that function(line 2). the function call console.log, which takes control, does its job and then returns control to line 2. there, it reaches the end of the greet function,so it returns to the place that called it-line4.the line after that calls console.log again.after that returns, the program reaches its end.

we could show the flow of control schematically like this:

because a function has to jump back to the place that called it when it returns, the computer must remember the context from which the call happened. in one case, console.log has to return to the greet function when it is done. in the other case, it returns to the end of the program.

the place where the computer stores this context is call stack. every time a function return, it removes the top context from the stack and uses that context to continue execute.
storing this stack requires space in the computer's memory. when the stack grows too big, the computer will fail with a message lile "out if stack space" or "too much recursion". the folowing code illustrates this by asking the computer a realy hard question that causes an infinite back-an-forth between two functions. or rather, it would be infinite, if the computer had an infinter stack. as it is, we wil run out of space, or "block the stack".

=========================optional arguments========
the following code is allowed and executes without any problem:

we defined square with only one parameter. yet when we call it with three, the language doesn't complain. it ignores the extra argument and computes the square of the first one.

javaScript is extremely broad-mined about the number of argument you can pass to a function. if you pass too many, the extra ones are ignored. if you pass too few, the missing parentheses are assigned the value undefined.
the downside of this is that it is possible-likely,even-that you'll accidentally pass the wrong number of arguments to functions. and no one will tell you about it. the upside is that you can use this behavior to allow a function to called with different numbers of arguments. for example, this minus function tries to imitate the - operator by acting on either one or two arguments:

if you write an = operator after a parameter, followed by an expression, the value of that expression will replace the argument when it is not given. for example, this version of routo makes its second argument optinal, if you don't provide it or pass the value undefined, it will default to one:

the next chapter will introduce a way in which a function body can get at the whole list of argument is was passed. this is helpful because it allows as function to accept any number of argument. for example, console.log does this , outputing all the values it is given.
===============closure======================
the ability to treat function as values, combined with the fact that local binding are re-created every time a function is called. bring up an interesting question: whten happens to local binding when the function call that created them is no longer active?
the following code shows an example of this. it defines a function, wrapvalue, that creates a local binding. it then returns a function that accesses and returns this local binding. 
this is allowed and works as you're hope-both instances of the binding can still be accesses. this situation is a good demonstration of the fact that local binding are created anew for every call, and different calls don't affect each other's local bindings.
this feature-being able to reference a specific instance of a local binding in an enclosing sope-is called closure. A function that refences bindings from local scopes around it is called a closure. this behavior not only frees you from having to worry about the lifetimes of bindings but also makes it possible to use function values in some creative ways.
with a slight change, we can turn the previous example into a way to create functions that multiple by an arbitrary amount.
the explicit local binding from the wrapvalue example isn't realy needed since a parameter is itself a local binding.
thinking about programs like this takes some practice. a good mental model is to think of function values as containing both the code in their body and the environment in which they are created. when called, the function body sees the environment in which it was created, not the environment in which it is called.
in the previous example, multipler is called and creates an environment in which its factor parameter is bound to 2. the function value it returns, which is stored in twice, remember this environment so that when that is called, it multiple its argument by 2.

==========================recursion=================
it is perfectly okey for a function to call itself, as long as it doesn't do it do often that it overflows the stack. a function that calls itself is called recursive. recursion allows some functions to be written in a different syle. take, for example, this power function, which does the same as the **(exponentiation) operator:

function power(base, exponent){
    if (exponent ===0){
        return 1;
    }else{
        return base*power(base,exponent-1);
    }
}
this is rather close to the way mathematicians define exponentiation and arguably describes the concept more clearly than the loop we used in chapter 2.
the function calls itself multiple times with ever smaller exponents to achieve the repeated multiple.
however thsi implementation has one problem: in typical javaScript implementations, it's about three times slower than version using a for loop. running through a simple loop is generally cheaper than calling a funcion multiple times.
the dilemma of speed versus elegance is an interesting one. you can see it as kind of continuum between human-friendliness and machine-friendliness. almost any program can be made faster by making it bigger and more convoluted.the programmer has to find an appropriate balance.
in the case of the power function, an inelegant(looping) version is still fairly simple and easy to read. it doesn't make much sense to replace it with recursive function.often though,a program deals with such complex concept that giving up some efficiency in order to make the program more straighforward is helpful.
worring about efficiency can be a distraction. it's yet another factor that complicates program design.and when you are doing something that's already difficult, that extra thing to worry about can be paralyzing.
therefore, you should generally start by writing something that's correct and easy to understand. if you're worried that it'too slow-which it usually itn't since most code simply isn't executed often enough to take any significant amount of time- you can measure afterward and improve it if necessary.
recursion is not always just an inefficient alternative to looping. some prolems really are easier to solve with recursion than with loop. most often these are problem that require exploring or processing several "branches", each of which might branch out again into even more branches.
consider this puzzle: by starting from the number 1 and repeated either adding 5 or multiplying by 3, an infinite set of numbers can be produced. how would you write a function that, given a number, tries to find a sequence of such additions and multiplications that produces that number? for example, the number 13 could be reached by first multiplying by 3 and then adding 5 twice, whereas the number 15 cannot be reached at all.
note that this program does not necessarily find the shortest sequence of operations. it is satisfied when it finds any sequence at all.

it is okey if you don not see how this code works right away, let's work through it since it makes for a great exercise in recursive thinking.

...




=======================growing functions===========
there are two more or less natural ways for functions to be introduced into program.
the first occurs when you find yourself writing similar code multiple times.you'd prefer not to do that, as having more code means space of mistakes to hide and more matetial to read of people trying to understand the program. so you take the repeated functionality, find a good name for it and put it into a function.

the second way is that you find you need some functionality that you haven't written yet and that sounds like it deserves its own function. you start by naming the function, and the write its body. you might even start wrting code that uses the function before you actually define the function itself.
how difficult it is to find a good name for a function is a good indication of how clear a concept it is that you're trying to wrap. let's go through an example.
we want to write a program that prints two numbersL the numbers of cows and chickens on a farm, with the words cows and chickens after them and zeros padded before both numbers so that they are always three digits long:

writing .length after a string expression will give us the length of that string. thus the while loops keep adding zeros in front of the number strings until they are at least three characters long.
============function and side effects=============
function can be roughly divided into those that are called for their side effect and those that are called for their return value ( though it is also possible to both have side effect and return a value).
the first helper function in the farm example, printZeroPaddedWithLabel, is called for its side effect: it prints a line, the second version zeropad, is called for its return value. it is no coincidence that the second is useful in more situation than the first. function that create values are easier to combine in new ways than function that directly perfrom side effect.
a pure function is a specific kind of value-producing function that not only has no side effect but also doesn't rely on side effect from other code -for example, it doesn;t read global binding whose value might change. a pure function has the pleasant property that, when called with the same arguments, it always produces the same value ( and doesn't do anything else). a call to such a function can be substituted by its return value without changing the meaning of the code. when you are not sure that a pure function is working correctly, you can test it by simply calling it and know that if it works in that context, it will work in any context. nonpure function tend to require more scaffolding to test.
still there's no need to feel bad when writing function that are not pure. side effect are often useful, there's no way to write a pure veriosn of console.log, for example and console.log is good to have. some operation are also easier to express in an efficient way when we use side effect.


===============summary=====================
this chapter taught you know how to write your own functions. the function keyword, when used as an expression can create a function value. when used as a statement, it can be used to declare a binding and give it a function as its value.arrow functions are yet another way to create functions.
a key part of understanding functions is understanding scopes. each block creates a new scope. parameters and bindings declared in a given scope are local and not visible from the outside. bindings declared with var behave differently- they end up in the nearest function into different functions is helpful. you won't have to repeat yourself as much, and functions can help organize a program by grouping code into pieces that do specific things.